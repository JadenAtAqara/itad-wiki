# Other Blocks

## Kit Batch Set

#### Introduction

The Kit Batch Set block lets you set the values of up to 8 different function points at the same time. This is useful for configuring many parameters in bulk or for device debugging. You can enter up to 8 values, and each one will be sent through a separate output port to your target function points. The batch setting will only take effect if the "Action" field receives "OK". This helps prevent mistakes and makes batch configuration more efficient and accurate.

#### Attribute Description

- **In A ~ In H**: Enter the values you want to set.
    - You can type the value directly, or connect constants, variables, or outputs from other blocks.
    - The default type is Number. If you want to change the type, double-click the top of the block to open the settings page, and edit the type for each input item.
- **Out A ~ Out H**: The corresponding output ports send each input value to the target function point or logic block.
    - Each input matches one output. For example, Input A outputs through Output A.
- **Action**: Controls when the batch setting happens. The batch set only works if you input `OK` here. This helps avoid mistakes.

#### Example

Here’s how to use it to set different brightness levels for multiple bulbs at once:

1. On the right side of the canvas, add several bulb brightness points, such as "Bulb 1 - Brightness," "Bulb 2 - Brightness," "Bulb 3 - Brightness," and "Bulb 4 - Brightness."
2. Add a **Kit Batch Set** block.
3. Set `In A` to 20, `In B` to 40, `In C` to 60, and `In D` to 80.
4. Connect the right side of Out A, B, C, and D to the "Input" port of each bulb brightness point.
5. Set the **Action** parameter to `OK`. This will batch set the brightness for each bulb: Bulb 1 to 20, Bulb 2 to 40, Bulb 3 to 60, and Bulb 4 to 80.

## Min Max Avg

#### Introduction

This logic block can analyze multiple input values. It calculates the minimum, maximum, and average values automatically.

#### Attribute Description

The default attributes displayed on the block:
- **In A ~ B**: You can set 2 numbers for analysis.
- **Min Value**: Outputs the minimum value among all valid inputs.
- **Max Value**: Outputs the maximum value among all valid inputs.
- **Average Value**: Outputs the average of all valid inputs.

To display more `In` inputs on the block, double-click to open the configuration panel, enable "Show" in the Flags for additional inputs, confirm your changes, and the new inputs will appear in the editor.

## Random

#### Introduction

With this logic block, you can get a random number.

#### Attribute Description

The default attributes displayed on the block:
- **Output**: Outputs a random number. You can connect this to a block o point that needs to use the value.

To configure the random number parameters, double-click the block to open the configuration panel:
- **Multiplier**: Determines the range of the random number. The result will be within `(Offset, Offset + Multiplier)`. For example, if Offset is 50 and Multiplier is 100, the random number will be between 50 and 150.
- **Offset**: Sets the minimum value for the random number. The result will not be less than this value. Default is 50.
- **Update Interval**: Controls how often a new random number is generated. If set to 1 second, a new random number will be output every second.

## Counter

#### Overview

The counter is a logic block used for accumulating counts. It supports count up, counter down, preset value, and clearing operations. It is suitable for scenarios where you need to count occurrences or accumulate numerical values.

Example Scenarios:
- People counting: counting the number of people entering or leaving.
- Device counting: recording the on/off or runtime counts of a device.
- Limited-use control: triggering a specific action after reaching a certain number of times.

#### Attribute Description

The default attributes displayed on the block:
- **Output**: It outputs the accumulated count value.
- **Count up**: It can be connected to the output of a function point or a [logic block](./logic-blocks.mdx); each time the output changes, the counter increments.

In addition, you can double-click the counter to configure the following extended attributes:
- **Preset Value**: You can set the initial value of the counter.
- **Count Increment**: You can set the increment/decrement step each time "Count up" or "Counter down" is triggered.
- **Counter down**: It can be connected to the output of a function point or a [logic block](./logic-blocks.mdx); each time the output changes, the counter decrements.
- **Preset**: It can be connected to the output of a function point or a [logic block](./logic-blocks.mdx); each time the output changes, the counter resets to the "Preset Value".
- **Clear**: Can be connected to the output of a function point or a [logic block](./logic-blocks.mdx); each time the output changes, the counter resets to 0.

#### Usage

Common use cases for the counter include:
- **Change-triggered counting**: Each time the monitored function point value changes, the counter increases by one. This is suitable for counting the total number of events. You can directly connect the output of the function point to this logic block.
- **Condition-triggered counting**: The counter only increments when the function point's value meets a specific condition (such as equals a certain value). This usually requires cooperation with a [logic block](./logic-blocks.mdx) to achieve conditional counting.

#### Examples

**Change-triggered counting**

For example, to count the total number of times a device switch changes:

1. Add the "Device - Switch Status" function point on the left side of the canvas.
2. Drag a **counter** logic block onto the canvas. 
3. Connect the "Device - Switch Status" output to the "Count up" input of the counter.
4. The counter's **Output** will show the accumulated number of switch changes.

**Condition-triggered counting**

For example, to count the number of times a light is turned on:

1. Add the "Light - Switch" function point.
2. Add an [Equal](./logic-blocks.mdx#equal) block to the canvas. Connect the "Input A" of the Equal block to the Output of the "Light - Switch" function point above, and set "Input B" as "1" (which represents the light being on).
3. Double-click the Equal block to open its settings panel, check "Show" in the `True` attribute's `Flags` to display this attribute on the block.
4. Drag a **counter** block onto the canvas. Connect the right endpoint of the `True` output above to the "Count up" of the counter.
5. The **Output** of the counter will then display the total number of times the light has turned on. The counter will only increment when the light turns on.

## While

#### Introduction

When you want to repeat an action, you can use this logic block to implement loop control and flexibly build periodic automation flows.

#### Attribute Description

By default, the following parameters are displayed:
- **Trigger**: The right-side endpoint connects to the target function point to be looped.
- **Active**: The left-side endpoint connects to a boolean data that triggers the loop.

To configure more parameters, double-click to open the settings panel. The configurable parameters include:
- **Every**: Set the interval between each action execution here, in seconds.
- **First trigger waits**: Set the delay before the first execution, in milliseconds. After the loop starts, it will first wait this duration before the initial trigger. All subsequent triggers use the "Every" interval. Proper configuration helps avoid device competition or starting multiple loops at once, and is suitable for scenarios like device initialization warm-up or staggered start. Unit: milliseconds.

#### Example

Below is an example of periodic air conditioning adjustment ("When a person is detected, automatically set the air conditioner to cooling mode 26℃ and auto fan speed every 1 hour"):

1. Add "Presence sensor - Existence state" as the loop trigger condition on the left side of the canvas, then add "AC - Mode", "AC - Temperature", and "AC - Fan Speed" function points in sequence on the right.
2. Drag in a **While** logic block and place it between them.
3. Double-click the block and set **Every** as `3600` seconds to achieve hourly automatic adjustment.
4. If you need to delay the first cycle execution, set the time in "First trigger waits" (e.g., 30000 ms, which equals 30 seconds).
5. Connect the output (Boolean type) of "Presence sensor - Existence state" to the **Active** port of the While logic block to ensure the automation only repeatedly runs when someone is present.
6. Double-click the While block, and in the `Trigger` parameter's `Flags`, check "Allow multiple target connections" so you can operate multiple function points at once.
7. Connect the "Trigger" output to the inputs of "AC - Mode", "AC - Temperature", "AC - Fan Speed", etc.
8. For each connection, double-click to open "Converter - Target Value", uncheck the original **status** value, and set the custom values you wish to send. For example: set AC mode to "Cooling", temperature to "26", and fan speed to "Auto".

With this configuration, when someone is present in the room, the air conditioner will automatically adjust to the specified state every hour, enhancing automation experience and saving energy.
